# -*- encoding: utf-8 -*-
# test_creating.py - unit tests for creating resources
#
# Copyright 2011 Lincoln de Sousa <lincoln@comum.org>.
# Copyright 2012, 2013, 2014, 2015, 2016 Jeffrey Finkelstein
#           <jeffrey.finkelstein@gmail.com> and contributors.
#
# This file is part of Flask-Restless.
#
# Flask-Restless is distributed under both the GNU Affero General Public
# License version 3 and under the 3-clause BSD license. For more
# information, see LICENSE.AGPL and LICENSE.BSD.
"""Unit tests for creating resources from endpoints generated by
Flask-Restless.

This module includes tests for additional functionality that is not
already tested by :mod:`test_jsonapi`, the package that guarantees
Flask-Restless meets the minimum requirements of the JSON API
specification.

"""
from __future__ import division

from sqlalchemy import Column
from sqlalchemy import Date
from sqlalchemy import DateTime
from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy import Interval
from sqlalchemy import Time
from sqlalchemy import Unicode
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import backref
from sqlalchemy.orm import relationship

from flask_restless import APIManager
from flask_restless import DeserializationException
from flask_restless import SerializationException

from .helpers import FlaskSQLAlchemyTestBase
from .helpers import ManagerTestBase
from .helpers import check_sole_error
from .test_serialization import build_serializer_with_exception


def raise_s_exception(instance, *_, **__):
    """Immediately raises a :exc:`SerializationException` with access to
    the provided `instance` of a SQLAlchemy model.

    This function is useful for use in tests for serialization
    exceptions.

    """

    raise SerializationException(instance=instance, resource_id=instance.id, resource_type='person')


def raise_d_exception(*args, **kw):
    """Immediately raises a :exc:`DeserializationException`.

    This function is useful for use in tests for deserialization
    exceptions.

    """
    class Deserializer:
        def deserialize(self, *_):
            raise DeserializationException()
    return Deserializer()


class TestCreating(ManagerTestBase):
    """Tests for creating resources."""

    def setUp(self):
        """Creates the database, the :class:`~flask.Flask` object, the
        :class:`~flask_restless.manager.APIManager` for that application, and
        creates the ReSTful API endpoints for the :class:`TestSupport.Person`
        and :class:`TestSupport.Article` models.

        """
        super().setUp()

        class Article(self.Base):
            __tablename__ = 'article'
            id = Column(Integer, primary_key=True)
            date_created = Column(Date)
            author_id = Column(Integer, ForeignKey('person.id'))

        class Person(self.Base):
            __tablename__ = 'person'
            id = Column(Integer, primary_key=True)
            age = Column(Integer)
            name = Column(Unicode, unique=True)
            birth_datetime = Column(DateTime, nullable=True)
            bedtime = Column(Time)
            hangtime = Column(Interval)
            articles = relationship('Article', backref='author')

            @hybrid_property
            def is_minor(self):
                if hasattr(self, 'age'):
                    if self.age is None:
                        return None
                    return self.age < 18
                return None

        class Tag(self.Base):
            __tablename__ = 'tag'
            name = Column(Unicode, primary_key=True)
            # TODO this dummy column is required to create an API for this
            # object.
            id = Column(Integer)

        self.Article = Article
        self.Person = Person
        self.Tag = Tag
        self.Base.metadata.create_all()
        self.manager.create_api(Person, methods=['POST'])
        self.manager.create_api(Article, methods=['POST'])
        self.manager.create_api(Tag, methods=['POST'], primary_key='name')

    def test_custom_serialization(self):
        """Tests for custom deserialization."""
        temp = []

        person_cls = self.Person

        class CustomSerializer:
            def serialize(self, instance, *args, **kw):
                result = {'attributes': {'foo': 'bar'}}
                result['attributes']['foo'] = temp.pop()
                return result

        class CustomDeserializer:

            def deserialize(self, document):
                # Move the attributes up to the top-level object.
                data = document['data']['attributes']
                temp.append(data.pop('foo'))
                instance = person_cls(**data)
                return instance

        # POST will deserialize once and serialize once
        self.manager.create_api(self.Person, methods=['POST'],
                                url_prefix='/api2',
                                serializer=CustomSerializer(),
                                deserializer=CustomDeserializer())
        data = dict(data=dict(type='person', attributes=dict(foo='bar')))
        response = self.app.post('/api2/person', json=data)
        assert response.status_code == 201
        document = response.json
        person = document['data']
        assert person['attributes']['foo'] == 'bar'

    def test_serialization_exception_included(self):
        """Tests that exceptions are caught when trying to serialize
        included resources.

        """
        person = self.Person(id=1)
        self.session.add(person)
        self.session.commit()
        self.manager.create_api(self.Article, methods=['POST'],
                                url_prefix='/api2')
        self.manager.create_api(self.Person, serializer=build_serializer_with_exception('person'))
        data = {
            'data': {
                'type': 'article',
                'relationships': {
                    'author': {
                        'data': {
                            'type': 'person',
                            'id': 1
                        }
                    }
                }
            }
        }
        query_string = {'include': 'author'}
        response = self.app.post('/api/article', json=data,
                                 query_string=query_string)
        check_sole_error(response, 500, ['Failed to serialize',
                                         'included resource', 'type', 'person',
                                         'ID', '1'])

    def test_deserialization_exception(self):
        """Tests that exceptions are caught when a custom deserialization
        method raises an exception.

        """
        self.manager.create_api(self.Person, methods=['POST'],
                                url_prefix='/api2',
                                deserializer=raise_d_exception())
        data = dict(data=dict(type='person'))
        response = self.app.post('/api2/person', json=data)
        assert response.status_code == 400
        # TODO check error message here

    def test_serialization_exception(self):
        """Tests that exceptions are caught when a custom serialization method
        raises an exception.

        """
        class CustomSerializer:
            def serialize(self, *args, **kwargs):
                raise_s_exception(*args)

        self.manager.create_api(self.Person, methods=['POST'], url_prefix='/api2', serializer=CustomSerializer())
        data = dict(data=dict(type='person'))
        response = self.app.post('/api2/person', json=data)
        assert response.status_code == 400
        # TODO check error message here

    def test_to_one_related_resource_url(self):
        """Tests that attempting to add to a to-one related resource URL
        (instead of a relationship URL) yields an error response.

        """
        article = self.Article(id=1)
        person = self.Person(id=1)
        self.session.add_all([article, person])
        self.session.commit()
        data = dict(data=dict(id=1, type='person'))
        response = self.app.post('/api/article/1/author', json=data)
        assert response.status_code == 405
        # TODO check error message here

    def test_to_many_related_resource_url(self):
        """Tests that attempting to add to a to-many related resource URL
        (instead of a relationship URL) yields an error response.

        """
        article = self.Article(id=1)
        person = self.Person(id=1)
        self.session.add_all([article, person])
        self.session.commit()
        data = dict(data=[dict(id=1, type='article')])
        response = self.app.post('/api/person/1/articles', json=data)
        assert response.status_code == 405
        # TODO check error message here

    def test_missing_data(self):
        """Tests that an attempt to update a resource without providing a
        "data" element yields an error.

        """
        data = dict(type='person')
        response = self.app.post('/api/person', json=data)
        assert response.status_code == 400
        keywords = ['deserialize', 'missing', '"data"', 'element']
        check_sole_error(response, 400, keywords)

    def test_to_one_relationship_missing_id(self):
        """Tests that the server rejects a request to create a resource
        with a to-one relationship when the relationship linkage object
        is missing an ``id`` element.

        """
        person = self.Person(id=1)
        self.session.add(person)
        self.session.commit()
        data = {
            'data': {
                'type': 'article',
                'relationships': {
                    'author': {
                        'data': {
                            'type': 'person'
                        }
                    }
                }
            }
        }
        response = self.app.post('/api/article', json=data)
        keywords = ['deserialize', 'missing', '"id"', 'element',
                    'linkage object', 'relationship', '"author"']
        check_sole_error(response, 400, keywords)

    def test_to_one_relationship_missing_type(self):
        """Tests that the server rejects a request to create a resource
        with a to-one relationship when the relationship linkage object
        is missing a ``type`` element.

        """
        person = self.Person(id=1)
        self.session.add(person)
        self.session.commit()
        data = {
            'data': {
                'type': 'article',
                'relationships': {
                    'author': {
                        'data': {
                            'id': '1'
                        }
                    }
                }
            }
        }
        response = self.app.post('/api/article', json=data)
        keywords = ['deserialize', 'missing', '"type"', 'element',
                    'linkage object', 'relationship', '"author"']
        check_sole_error(response, 400, keywords)

    def test_to_one_relationship_conflicting_type(self):
        """Tests that the server rejects a request to create a resource
        with a to-one relationship when the relationship linkage object
        has a ``type`` element that conflicts with the actual type of
        the related resource.

        """
        person = self.Person(id=1)
        self.session.add(person)
        self.session.commit()
        data = {
            'data': {
                'type': 'article',
                'relationships': {
                    'author': {
                        'data': {
                            'id': '1',
                            'type': 'article'
                        }
                    }
                }
            }
        }
        response = self.app.post('/api/article', json=data)
        keywords = ['deserialize', 'expected', 'type', '"person"', '"article"',
                    'linkage object', 'relationship', '"author"']
        check_sole_error(response, 409, keywords)

    def test_to_many_relationship_missing_id(self):
        """Tests that the server rejects a request to create a resource
        with a to-many relationship when any of the relationship linkage
        objects is missing an ``id`` element.

        """
        article = self.Article(id=1)
        self.session.add(article)
        self.session.commit()
        data = {
            'data': {
                'type': 'person',
                'relationships': {
                    'articles': {
                        'data': [
                            {'type': 'article'}
                        ]
                    }
                }
            }
        }
        response = self.app.post('/api/person', json=data)
        keywords = ['deserialize', 'missing', '"id"', 'element',
                    'linkage object', 'relationship', '"articles"']
        check_sole_error(response, 400, keywords)

    def test_to_many_relationship_missing_type(self):
        """Tests that the server rejects a request to create a resource
        with a to-many relationship when any of the relationship linkage
        objects is missing a ``type`` element.

        """
        article = self.Article(id=1)
        self.session.add(article)
        self.session.commit()
        data = {
            'data': {
                'type': 'person',
                'relationships': {
                    'articles': {
                        'data': [
                            {'id': '1'}
                        ]
                    }
                }
            }
        }
        response = self.app.post('/api/person', json=data)
        keywords = ['deserialize', 'missing', '"type"', 'element',
                    'linkage object', 'relationship', '"articles"']
        check_sole_error(response, 400, keywords)

    def test_to_many_relationship_conflicting_type(self):
        """Tests that the server rejects a request to create a resource
        with a to-many relationship when any of the relationship linkage
        objects has a ``type`` element that conflicts with the actual
        type of the related resource.

        """
        person = self.Person(id=1)
        self.session.add(person)
        self.session.commit()
        data = {
            'data': {
                'type': 'person',
                'relationships': {
                    'articles': {
                        'data': [
                            {
                                'id': '1',
                                'type': 'person'
                            }
                        ]
                    }
                }
            }
        }
        response = self.app.post('/api/person', json=data)
        keywords = ['deserialize', 'expected', 'type', '"article"', '"person"',
                    'linkage object', 'relationship', '"articles"']
        check_sole_error(response, 409, keywords)


class TestAssociationProxy(ManagerTestBase):
    """Tests for creating an object with a relationship using an association
    proxy.

    """

    def setUp(self):
        """Creates the database, the :class:`~flask.Flask` object, the
        :class:`~flask_restless.manager.APIManager` for that application,
        and creates the ReSTful API endpoints for the models used in the test
        methods.

        """
        super().setUp()

        class Article(self.Base):
            __tablename__ = 'article'
            id = Column(Integer, primary_key=True)
            tags = association_proxy('articletags', 'tag',
                                     creator=lambda tag: ArticleTag(tag=tag))

        class ArticleTag(self.Base):
            __tablename__ = 'articletag'
            article_id = Column(Integer, ForeignKey('article.id'),
                                primary_key=True)
            article = relationship(Article, backref=backref('articletags'))
            tag_id = Column(Integer, ForeignKey('tag.id'), primary_key=True)
            tag = relationship('Tag')
            # TODO this dummy column is required to create an API for this
            # object.
            id = Column(Integer)

        class Tag(self.Base):
            __tablename__ = 'tag'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode)

        self.Tag = Tag
        self.Base.metadata.create_all()
        self.manager.create_api(Article, methods=['POST'])
        # HACK Need to create APIs for these other models because otherwise
        # we're not able to create the link URLs to them.
        #
        # TODO Fix this by simply not creating links to related models for
        # which no API has been made.
        self.manager.create_api(Tag)
        self.manager.create_api(ArticleTag, primary_key='article_id')

    def test_create(self):
        """Test for creating a new instance of the database model that has a
        many-to-many relation that uses an association object to allow extra
        information to be stored on the association table.

        """
        tag1 = self.Tag(id=1)
        tag2 = self.Tag(id=2)
        self.session.add_all([tag1, tag2])
        self.session.commit()
        data = {
            'data': {
                'type': 'article',
                'relationships': {
                    'tags': {
                        'data': [
                            {'type': 'tag', 'id': '1'},
                            {'type': 'tag', 'id': '2'}
                        ]
                    }
                }
            }
        }
        response = self.app.post('/api/article', json=data)
        assert response.status_code == 201
        document = response.json
        article = document['data']
        tags = article['relationships']['tags']['data']
        assert ['1', '2'] == sorted(tag['id'] for tag in tags)


class TestFlaskSQLAlchemy(FlaskSQLAlchemyTestBase):
    """Tests for creating resources defined as Flask-SQLAlchemy models instead
    of pure SQLAlchemy models.

    """

    def setUp(self):
        """Creates the Flask-SQLAlchemy database and models."""
        super(TestFlaskSQLAlchemy, self).setUp()

        class Person(self.db.Model):
            id = self.db.Column(self.db.Integer, primary_key=True)

        self.Person = Person
        self.db.create_all()
        self.manager = APIManager(self.flaskapp, session=self.db.session)
        self.manager.create_api(self.Person, methods=['POST'])

    def test_create(self):
        """Tests for creating a resource."""
        data = dict(data=dict(type='person'))
        response = self.app.post('/api/person', json=data)
        assert response.status_code == 201
        document = response.json
        person = document['data']
        # TODO To make this test more robust, should query for person objects.
        assert person['id'] == '1'
        assert person['type'] == 'person'
